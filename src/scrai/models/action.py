"""
Action model representing intended behaviors in the simulation.

An Action represents something an actor intends to do or a decision they want to make.
Actions are processed by the simulation engine and may result in Events.
"""

from typing import Dict, Any, Optional, List
from datetime import datetime
from pydantic import BaseModel, Field
from enum import Enum


class ActionType(str, Enum):
    """Types of actions in the simulation."""
    MOVEMENT = "movement"
    COMMUNICATION = "communication"
    INTERACTION = "interaction"
    ECONOMIC = "economic"
    SOCIAL = "social"
    COMBAT = "combat"
    RESEARCH = "research"
    CUSTOM = "custom"


class ActionStatus(str, Enum):
    """Status of actions in the simulation."""
    PENDING = "pending"
    APPROVED = "approved"
    EXECUTING = "executing"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class ActionPriority(str, Enum):
    """Priority levels for actions."""
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    URGENT = "urgent"


class Action(BaseModel):
    """
    Represents an action in the simulation.
    
    An action is something an actor intends to do. Actions are processed
    by the simulation engine and may result in Events affecting the world.
    """
    
    id: str = Field(..., description="Unique identifier for the action")
    actor_id: str = Field(..., description="ID of the actor performing this action")
    type: ActionType = Field(..., description="Type/category of the action")
    
    # Action definition
    intent: str = Field(..., description="What the actor intends to do (free text)")
    description: str = Field(..., description="Detailed description of the action")
    
    # Structured data
    parameters: Dict[str, Any] = Field(
        default_factory=dict,
        description="Structured parameters for the action"
    )
    target_actor_ids: List[str] = Field(
        default_factory=list,
        description="IDs of other actors this action targets"
    )
    target_location: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Location this action targets"
    )
    
    # Status and processing
    status: ActionStatus = Field(default=ActionStatus.PENDING, description="Current status")
    priority: ActionPriority = Field(default=ActionPriority.NORMAL, description="Action priority")
    
    # Timing
    created_at: datetime = Field(default_factory=datetime.utcnow)
    scheduled_for: Optional[datetime] = Field(default=None, description="When action should execute")
    started_at: Optional[datetime] = Field(default=None, description="When execution started")
    completed_at: Optional[datetime] = Field(default=None, description="When action completed")
    
    # Processing data
    llm_parsed: bool = Field(default=False, description="Whether LLM has parsed this action")
    parsed_options: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Options parsed by LLM from the intent"
    )
    selected_option: Optional[int] = Field(default=None, description="Index of selected option")
    
    # Requirements and constraints
    prerequisites: List[str] = Field(
        default_factory=list,
        description="Prerequisites that must be met"
    )
    resource_costs: Dict[str, Any] = Field(
        default_factory=dict,
        description="Resources required for this action"
    )
    
    # Results
    success_probability: Optional[float] = Field(default=None, description="Calculated success probability")
    outcome: Optional[str] = Field(default=None, description="Actual outcome after execution")
    generated_events: List[str] = Field(
        default_factory=list,
        description="IDs of events generated by this action"
    )
    
    # Researcher mediation
    requires_approval: bool = Field(default=False, description="Whether action needs researcher approval")
    approved_by: Optional[str] = Field(default=None, description="Researcher who approved action")
    modifications: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Modifications made by researchers"
    )
    
    # Metadata
    source: str = Field(default="player", description="Source of this action (player, npc, system)")
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional metadata"
    )
    
    def approve(self, approved_by: str) -> None:
        """Approve the action for execution."""
        self.status = ActionStatus.APPROVED
        self.approved_by = approved_by
    
    def start_execution(self) -> None:
        """Mark action as starting execution."""
        self.status = ActionStatus.EXECUTING
        self.started_at = datetime.utcnow()
    
    def complete(self, outcome: str, success: bool = True) -> None:
        """Mark action as completed."""
        self.status = ActionStatus.COMPLETED if success else ActionStatus.FAILED
        self.completed_at = datetime.utcnow()
        self.outcome = outcome
    
    def cancel(self, reason: str = "") -> None:
        """Cancel the action."""
        self.status = ActionStatus.CANCELLED
        if reason:
            self.metadata["cancellation_reason"] = reason
    
    def add_parsed_option(self, option: Dict[str, Any]) -> None:
        """Add a parsed option from LLM processing."""
        self.parsed_options.append(option)
        self.llm_parsed = True
    
    def select_option(self, option_index: int) -> None:
        """Select one of the parsed options."""
        if 0 <= option_index < len(self.parsed_options):
            self.selected_option = option_index
        else:
            raise ValueError(f"Invalid option index: {option_index}")
    
    def add_generated_event(self, event_id: str) -> None:
        """Add an event ID that was generated by this action."""
        if event_id not in self.generated_events:
            self.generated_events.append(event_id)
    
    def add_modification(self, field: str, old_value: Any, new_value: Any, modified_by: str) -> None:
        """Record a modification made by a researcher."""
        modification = {
            "field": field,
            "old_value": old_value,
            "new_value": new_value,
            "modified_by": modified_by,
            "modified_at": datetime.utcnow().isoformat()
        }
        self.modifications.append(modification)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert action to dictionary for storage."""
        return self.model_dump(mode='json')
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Action':
        """Create action from dictionary."""
        return cls(**data)
    
    def __str__(self) -> str:
        return f"Action({self.intent[:50]}{'...' if len(self.intent) > 50 else ''}, {self.status.value})"
    
    def __repr__(self) -> str:
        return f"Action(id='{self.id}', actor_id='{self.actor_id}', type='{self.type.value}', status='{self.status.value}')"